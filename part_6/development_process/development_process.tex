%\section{Development Process}
The development process was done using Agile Software Development Techniques, especially Scrums daily meetings and Pair Programming. The choice of Agile techniques was motivated by the iterative way the problem explication and requirements collection processes were carried out. A waterfall like development process where all requirements are collected before starting development was considered but would not have allowed us to iteratively define requirements. This development method could therefore have resulted in an artefact that doesn't achieve the goals.
The requirements were split into smaller tasks that were added in a project management tool. When new functionality was detected these functions were added to the feature backlog. When functions were implemented new functions from the backlog were picked out and developed. One day every week a meeting was arranged with the stakeholder to give update on the development progress. In these meetings problems was highlighted and sometimes new requirements were announced by the stakeholder. With the requirements collected from the stakeholder it was clear that the chosen middleware, the MediaSense platform, needed to be split into two pieces. The resource heavy modules in the middleware should be able to run once on a device and several application should be able to use them. 

The way MediaSense worked meant an application was started together with the platform behaved as a single instance. Thus, the application had access to all of the platforms functionality. Splitting up the application and platform would mean the application would run as a separate instance and therefore not have access to the platforms methods, a means of communication would be needed between application and platform to make this functionality available. MediaSense is written in Java and Java programs are executed in Java Virtual Machines (JVM). This means that the platform would run in one JVM and then several applications can be started and communicate with the platform from their own JVMs. Because one of the requirements previously discovered was that applications should be able to run on other devices and use the platform as a gateway, this communication would need to work remotely over network.

A document study of Remote Procedure Call (RPC) implementations was initiated to decide how applications should communicate with the platform. By comparing the gathered information about different RPC implementations we decided on using Remote Method Invocation which is a Java specific RPC implementation. RMI supports sending entire Java objects as parameters which complies with the requirement of keeping the Object oriented style of MediaSense. It also forces all remote objects to throw RemoteExceptions which facilitates the Application Independent requirement because the platform can catch the exceptions thrown by applications and avoid going down with them. The main drawback with using RMI is that it is not as lightweight as other RPC implementations, but the resource overhead this causes is small in comparison to running several instances of the MediaSense platform.

To find the best way to change the architecture of MediaSense several participative modelling sessions were held where models of the old architecture were drawn on the whiteboard and changes was applied on these models to find the best solution to solve the problem.
